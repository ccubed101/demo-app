import { Injectable } from '@angular/core';

import { from } from 'rxjs';

import { BreezeDemoEntityManager } from './BreezeDemoEntityManager'

import { EntityManager, EntityType, AutoGeneratedKeyType, NamingConvention, ComplexType, EntityState, SaveOptions } from 'breeze-client';

import { ICourseRepository, CourseRepository } from './CourseRepository'
import { IStudentRepository, StudentRepository } from './StudentRepository'
import { IEnrollmentRepository, EnrollmentRepository } from './EnrollmentRepository'
import { ITeacherRepository, TeacherRepository } from './TeacherRepository'

export interface IUnitOfWork {
    Courses: ICourseRepository;
    Students: IStudentRepository;
    Enrollments: IEnrollmentRepository;
    SaveChanges(): void;
}

//// Specifying providers can be done as shown below (as opposed to being done in the NgModule
//// declaration).  But this could cause problems.  In particular there was some conflict with
//// Ngrx.
//@Injectable({
//    providedIn: NgrxPlusBreezeModule
//})
export class UnitOfWork implements IUnitOfWork {

    // Construction.

    constructor(
        // Here everything is injected.  However an alternative is to inject only the UnitOfWork
        // and then instantiate all of the repositories in the constructor.  See the commented
        // out code below.
        private entityManager: BreezeDemoEntityManager,
        private courses: CourseRepository,
        private students: StudentRepository,
        private enrollments: EnrollmentRepository,
        private teachers: TeacherRepository,
    ) {

        from(this.entityManager.fetchMetadata()).subscribe(
            (schema) => {
                this.schema = schema;
                console.log(schema);

                // All entity types will have there unique IDs determime by the back-end database.
                let entityTypes = this.entityManager.metadataStore.getEntityTypes()
                for (let entityType of entityTypes) {
                    if (entityType instanceof EntityType) {
                        (<EntityType>entityType).setProperties({
                            autoGeneratedKeyType: AutoGeneratedKeyType.Identity
                        })
                    }
                }

                // Invoke method that is called when loading of metadata has completed.
                if (this.metadataLoadedCallback != null)
                    this.metadataLoadedCallback();
            },
            (error) => {
                console.log(error);
                this.error = error;
            },
        );
        
        //this.courses = new CourseRepository();
        //this.students = new StudentRepository();
        //this.enrollments = new EnrollmentRepository();
    }

    // Instance variables.

    //private readonly classes: CourseRepository = new CourseRepository();
    //private readonly students: StudentRepository = new StudentRepository();
    //private readonly enrollments: EnrollmentRepository = new EnrollmentRepository();

    // When EntityManager.fetchMetadata() is called the result is store in 'schema'; or if there
    // is a error then the error is stored in 'error'.
    schema: any = null;
    error: any = null;

    metadataLoadedCallback: () => void = null;


    // Property Accessors.

    get Courses(): ICourseRepository {
        return this.courses;
    }

    get Students(): IStudentRepository {
        return this.students;
    }

    get Enrollments(): IEnrollmentRepository {
        return this.enrollments;
    }

    get Teachers(): ITeacherRepository {
        return this.teachers;
    }

    set MetadataLoadedCallback(value: () => void) {
        this.metadataLoadedCallback = value;
    }


    // Methods

    SaveChanges(): void {


        console.log("Courses before");
        let entityType: EntityType | ComplexType = this.entityManager.metadataStore.getEntityType("Course");
        for (let e of this.entityManager.getEntities([<EntityType>entityType], [EntityState.Added, EntityState.Unchanged, EntityState.Modified])) {
            console.log(e);
        }


        if (this.entityManager.hasChanges) {
            this.entityManager.saveChanges()
                .then((saveResult) => {
                    console.log(saveResult);



                    console.log("Courses after");
                    let entityType: EntityType | ComplexType = this.entityManager.metadataStore.getEntityType("Course");
                    for (let e of this.entityManager.getEntities([<EntityType>entityType], [EntityState.Added, EntityState.Unchanged, EntityState.Modified])) {
                        console.log(e);
                    }




                })
                .catch((error) => {
                    console.log(error);
                });
        }
    }
}
