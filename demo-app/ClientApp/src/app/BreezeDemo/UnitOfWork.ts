import { Injectable } from '@angular/core';

import { from } from 'rxjs';

import { BreezeDemoEntityManager } from './BreezeDemoEntityManager'

import { EntityManager, EntityType, AutoGeneratedKeyType, NamingConvention, ComplexType, EntityState, SaveOptions } from 'breeze-client';

import { ITeacherRepository, TeacherRepository } from './TeacherRepository'
import { ICourseRepository, CourseRepository } from './CourseRepository'
import { IStudentRepository, StudentRepository } from './StudentRepository'
import { IStudentEnrollmentRepository, StudentEnrollmentRepository } from './StudentEnrollmentRepository'
import { ITeacherAssignmentRepository, TeacherAssignmentRepository } from './TeacherAssignmentRepository'

export interface IUnitOfWork {
    Teachers: ITeacherRepository;
    Courses: ICourseRepository;
    Students: IStudentRepository;
    TeacherAssignments: ITeacherAssignmentRepository;
    StudentEnrollments: IStudentEnrollmentRepository;
    SaveChanges(): void;
}

//// Specifying providers can be done as shown below (as opposed to being done in the NgModule
//// declaration).  But this could cause problems.  In particular there was some conflict with
//// Ngrx.
//@Injectable({
//    providedIn: NgrxPlusBreezeModule
//})
@Injectable()
export class UnitOfWork implements IUnitOfWork {

    // Construction.

    constructor(
        // Here everything is injected.  However an alternative is to inject only the UnitOfWork
        // and then instantiate all of the repositories in the constructor.  See the commented
        // out code below.
        private entityManager: BreezeDemoEntityManager,
        private teachers: TeacherRepository,
        private courses: CourseRepository,
        private students: StudentRepository,
        private teacherAssignments: TeacherAssignmentRepository,
        private studentEnrollments: StudentEnrollmentRepository,
    ) {
        from(this.entityManager.fetchMetadata()).subscribe(
            (schema) => {
                this.schema = schema;

                // Specify that all entity types will have their unique IDs determime by the back-end database.
                let entityTypes = this.entityManager.metadataStore.getEntityTypes();
                for (let entityType of entityTypes) {
                    if (entityType instanceof EntityType) {
                        (<EntityType>entityType).setProperties({
                            autoGeneratedKeyType: AutoGeneratedKeyType.Identity
                        })
                    }
                }

                // Invoke method that is called when loading of metadata has completed.
                if (this.metadataLoadedCallback !== null) {
                    this.metadataLoadedCallback();
                }
            },
            (error) => {
                console.log(error);
                this.error = error;
            },
        );
        
        //this.courses = new CourseRepository();
        //this.students = new StudentRepository();
        //this.enrollments = new EnrollmentRepository();
    }

    // Instance variables.

    //private readonly classes: CourseRepository = new CourseRepository();
    //private readonly students: StudentRepository = new StudentRepository();
    //private readonly enrollments: EnrollmentRepository = new EnrollmentRepository();

    // When EntityManager.fetchMetadata() is called the result is store in 'schema'; or if there
    // is a error then the error is stored in 'error'.
    schema: any = null;
    error: any = null;

    metadataLoadedCallback: () => void = null;


    // Property Accessors.

    get Teachers(): ITeacherRepository {
        return this.teachers;
    }

    get Courses(): ICourseRepository {
        return this.courses;
    }

    get Students(): IStudentRepository {
        return this.students;
    }

    get TeacherAssignments(): ITeacherAssignmentRepository {
        return this.teacherAssignments;
    }

    get StudentEnrollments(): IStudentEnrollmentRepository {
        return this.studentEnrollments;
    }

    set MetadataLoadedCallback(value: () => void) {
        this.metadataLoadedCallback = value;
    }


    // Methods

    SaveChanges(): void {


        //console.log("Courses before");
        //let entityType: EntityType | ComplexType = this.entityManager.metadataStore.getEntityType("Course");
        //for (let e of this.entityManager.getEntities([<EntityType>entityType], [EntityState.Added, EntityState.Unchanged, EntityState.Modified])) {
        //    console.log(e);
        //}


        if (this.entityManager.hasChanges) {
            this.entityManager.saveChanges()
                .then((saveResult) => {

                    //console.log(saveResult);

                    //console.log("Courses after");
                    //let entityType: EntityType | ComplexType = this.entityManager.metadataStore.getEntityType("Course");
                    //for (let e of this.entityManager.getEntities([<EntityType>entityType], [EntityState.Added, EntityState.Unchanged, EntityState.Modified])) {
                    //    console.log(e);
                    //}

                })
                .catch((error) => {
                    console.log(error);
                });
        }
    }
}
